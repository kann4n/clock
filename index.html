<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Space Clock â€“ Responsive</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
        }

        body {
            display: grid;
            place-items: center;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background: radial-gradient(ellipse at bottom, #1b2735 0%, #090a0f 100%);
            font-family: "Orbitron", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            position: relative;
        }

        .github-link {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            width: 48px;
            height: 48px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
            transition: background 0.3s, transform 0.2s;
            z-index: 9999;
            backdrop-filter: blur(6px);
            box-shadow: 0 0 12px rgba(0, 150, 255, 0.3);
        }

        .github-link:hover {
            background: rgba(0, 150, 255, 0.3);
            transform: scale(1.1);
        }

        .github-link svg {
            width: 24px;
            height: 24px;
        }





        /* Starfield */
        body::before {
            content: "";
            position: absolute;
            inset: 0;
            z-index: 0;
            background: transparent url("https://www.transparenttextures.com/patterns/stardust.png") repeat;
            animation: stars 200s linear infinite;
            opacity: 0.6;
        }

        @keyframes stars {
            from {
                background-position: 0 0;
            }

            to {
                background-position: -10000px 5000px;
            }
        }

        .clock-wrap {
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 1.2rem;
            align-items: center;
            z-index: 1;
        }

        /* The canvas scales with viewport; internal pixels are managed by JS for sharpness */
        #clockCanvas {
            width: min(90vw, 80vh);
            height: auto;
            aspect-ratio: 1 / 1;
            border-radius: 50%;
            background:
                radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.06), rgba(0, 0, 0, 0.12));
            box-shadow:
                0 20px 40px rgba(0, 0, 0, 0.35), inset 0 0 0 8px rgba(255, 255, 255, 0.05), inset 0 0 20px rgba(0, 0, 0, 0.25);
        }

        .digital-time {
            color: #0ff;
            letter-spacing: 0.1em;
            font-weight: 500;
            text-align: center;
            font-size: clamp(16px, 5vw, 28px);
            text-shadow: 0 0 10px #0ff, 0 0 20px #09f;
            background: rgba(0, 0, 0, 0.25);
            padding: 0.6em 1.2em;
            border-radius: 999px;
            border: 1px solid rgba(0, 255, 255, 0.25);
            backdrop-filter: blur(8px);
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.75;
            }
        }

        .pulse {
            animation: pulse 1s ease-in-out;
        }
    </style>
</head>

<body>
    <div class="clock-wrap">
        <canvas id="clockCanvas"></canvas>
        <div id="digitalTime" class="digital-time">00:00:00</div>
    </div>
    <a href="https://github.com/kann4n/clock" target="_blank" class="github-link"
        aria-label="View on GitHub">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
            <path
                d="M12 .5C5.7.5.5 5.7.5 12c0 5.1 3.3 9.3 7.9 10.8.6.1.8-.2.8-.6v-2c-3.2.7-3.9-1.4-3.9-1.4-.6-1.4-1.5-1.7-1.5-1.7-1.2-.8.1-.8.1-.8 1.3.1 2 1.3 2 1.3 1.1 2 2.9 1.4 3.6 1.1.1-.8.4-1.4.7-1.7-2.6-.3-5.4-1.3-5.4-5.8 0-1.3.5-2.4 1.2-3.2-.1-.3-.5-1.5.1-3.1 0 0 1-.3 3.3 1.2a11.6 11.6 0 0 1 6 0c2.3-1.5 3.3-1.2 3.3-1.2.6 1.6.2 2.8.1 3.1.8.8 1.2 1.9 1.2 3.2 0 4.6-2.8 5.5-5.5 5.8.4.3.8 1 .8 2v3c0 .3.2.7.8.6 4.6-1.5 7.9-5.7 7.9-10.8C23.5 5.7 18.3.5 12 .5Z" />
        </svg>
    </a>

    <!-- Place an eff.mp3 beside this file. Short, subtle click/boom works best. -->
    <audio id="impactSound" preload="auto" src="assets/eff.wav"></audio>

    <script>
        const canvas = document.getElementById('clockCanvas');
        const ctx = canvas.getContext('2d', { alpha: true });
        const digitalTime = document.getElementById('digitalTime');
        const impactSound = document.getElementById('impactSound');

        // Geometry state (updated on resize)
        let sizeCSS = 0;            // CSS pixels (display size)
        let dpr = 1;                // devicePixelRatio
        let R = 0;                  // clock radius in device pixels
        let cx = 0, cy = 0;         // center in device pixels

        // Asteroids stored in normalized space so they survive resizes
        // u,v in [0,1] relative to canvas
        const ASTERIOD_COUNT = 10; // intentionally misspelled per request vibe ;)
        const asteroids = [];
        const explosions = []; // particle bursts

        function rand(min, max) { return min + Math.random() * (max - min); }

        function makeAsteroid() {
            return {
                u: Math.random(),
                v: Math.random(),
                // Size relative to clock radius so it scales cleanly
                rRel: rand(0.015, 0.03),
                angle: rand(0, Math.PI * 2),
                angVel: rand(-0.6, 0.6) / 180 * Math.PI, // slow drift
                destroyed: false,
            };
        }

        for (let i = 0; i < ASTERIOD_COUNT; i++) asteroids.push(makeAsteroid());

        function resizeCanvas() {
            // Compute CSS size from the element's bounding rect (already responsive via CSS)
            const rect = canvas.getBoundingClientRect();
            sizeCSS = Math.min(rect.width, rect.height);

            // Set internal pixel size for crisp rendering on high-DPI screens
            dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
            canvas.width = Math.round(sizeCSS * dpr);
            canvas.height = Math.round(sizeCSS * dpr);

            cx = canvas.width / 2; cy = canvas.height / 2; R = Math.min(cx, cy) - 10 * dpr;

            // Use a fresh transform each frame, so no ctx.translate here
        }

        // Helpers to convert normalized asteroid position to device pixels
        function toPx(a) {
            return {
                x: a.u * canvas.width,
                y: a.v * canvas.height,
                r: a.rRel * R,
            };
        }

        function drawClockFace() {
            ctx.save();
            ctx.translate(cx, cy);
            const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, R);
            grad.addColorStop(0, 'rgba(255,255,255,0.10)');
            grad.addColorStop(0.95, 'rgba(100,100,100,0.06)');
            grad.addColorStop(1, 'rgba(0,0,0,0.35)');
            ctx.beginPath(); ctx.arc(0, 0, R, 0, Math.PI * 2);
            ctx.fillStyle = grad; ctx.fill();
            ctx.strokeStyle = 'rgba(0,255,255,0.18)'; ctx.lineWidth = 2 * dpr; ctx.stroke();
            // Center node
            ctx.beginPath(); ctx.arc(0, 0, 8 * dpr, 0, Math.PI * 2); ctx.fillStyle = '#0ff'; ctx.fill();
            ctx.restore();
        }

        function drawTicks() {
            ctx.save();
            ctx.translate(cx, cy);
            for (let i = 0; i < 60; i++) {
                const a = (i * Math.PI * 2) / 60;
                const isHour = i % 5 === 0;
                const inner = R - (isHour ? 25 * dpr : 15 * dpr);
                const outer = R - 5 * dpr;
                ctx.beginPath();
                ctx.moveTo(Math.cos(a) * inner, Math.sin(a) * inner);
                ctx.lineTo(Math.cos(a) * outer, Math.sin(a) * outer);
                ctx.lineWidth = (isHour ? 3 : 1) * dpr;
                ctx.strokeStyle = isHour ? '#0ff' : 'rgba(0,255,255,0.5)';
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawNumbers() {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillStyle = '#0ff';
            ctx.font = `bold ${Math.round(R * 0.15)}px Orbitron`;
            for (let n = 1; n <= 12; n++) {
                const a = (n * Math.PI * 2) / 12 - Math.PI / 2;
                const x = Math.cos(a) * (R - 40 * dpr);
                const y = Math.sin(a) * (R - 40 * dpr);
                ctx.fillText(String(n), x, y);
            }
            ctx.restore();
        }

        function drawHand(angle, lengthRel, widthRel, color) {
            ctx.save();
            ctx.translate(cx, cy);
            const len = R * lengthRel;
            const w = Math.max(1.5 * dpr, R * widthRel);
            ctx.shadowBlur = 15 * dpr; ctx.shadowColor = color;
            ctx.beginPath(); ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(angle) * len, Math.sin(angle) * len);
            ctx.lineWidth = w; ctx.lineCap = 'round'; ctx.strokeStyle = color; ctx.stroke();
            ctx.shadowBlur = 0;
            // Counterweight
            ctx.beginPath(); ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(angle + Math.PI) * (len * 0.2), Math.sin(angle + Math.PI) * (len * 0.2));
            ctx.lineWidth = w * 0.8; ctx.stroke();
            ctx.restore();
        }

        function drawAsteroids(dt) {
            ctx.save();
            for (const a of asteroids) {
                if (a.destroyed) continue;
                a.angle += a.angVel * dt; // gentle spin/drift over time
                const p = toPx(a);
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                ctx.fillStyle = '#ffec6e'; ctx.fill();
                // tiny highlight
                ctx.beginPath(); ctx.arc(p.x - p.r * 0.4, p.y - p.r * 0.4, p.r * 0.25, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255,255,255,0.65)'; ctx.fill();
            }
            ctx.restore();
        }

        function spawnExplosion(x, y) {
            // Basic particle burst
            const N = 12;
            for (let i = 0; i < N; i++) {
                explosions.push({
                    x, y,
                    vx: Math.cos((i / N) * Math.PI * 2) * rand(30, 90) * dpr,
                    vy: Math.sin((i / N) * Math.PI * 2) * rand(30, 90) * dpr,
                    life: 0.4, // seconds
                    r: rand(2, 4) * dpr,
                });
            }
        }

        function drawExplosions(dt) {
            ctx.save();
            for (let i = explosions.length - 1; i >= 0; i--) {
                const p = explosions[i];
                p.life -= dt; if (p.life <= 0) { explosions.splice(i, 1); continue; }
                // integrate
                p.x += p.vx * dt; p.y += p.vy * dt;
                const alpha = Math.max(0, p.life / 0.4);
                ctx.globalAlpha = alpha;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
                ctx.fillStyle = '#ffd36b'; ctx.fill();
                ctx.globalAlpha = 1;
            }
            ctx.restore();
        }

        function formatTime(t) {
            const h = String(t.getHours()).padStart(2, '0');
            const m = String(t.getMinutes()).padStart(2, '0');
            const s = String(t.getSeconds()).padStart(2, '0');
            return `${h}:${m}:${s}`;
        }

        // Pointer hit-test helper (client -> device px)
        function clientToCanvas(evt) {
            const rect = canvas.getBoundingClientRect();
            const xCSS = (evt.clientX - rect.left) * (canvas.width / rect.width);
            const yCSS = (evt.clientY - rect.top) * (canvas.height / rect.height);
            return { x: xCSS, y: yCSS };
        }

        function handleHit(evt) {
            // Ensure sound is allowed on first gesture
            if (impactSound && impactSound.paused) {
                try { impactSound.play().catch(() => { }); impactSound.pause(); impactSound.currentTime = 0; } catch { }
            }

            const { x, y } = clientToCanvas(evt);
            for (const a of asteroids) {
                if (a.destroyed) continue;
                const p = toPx(a);
                const dx = x - p.x, dy = y - p.y;
                if (Math.hypot(dx, dy) <= p.r + 6 * dpr) {
                    a.destroyed = true;
                    spawnExplosion(p.x, p.y);
                    try { impactSound.currentTime = 0; impactSound.play(); } catch { }
                }
            }
        }

        canvas.addEventListener('pointerdown', handleHit, { passive: true });

        // Main loop
        let last = performance.now();
        function loop(now) {
            const dt = Math.min(0.05, (now - last) / 1000); // clamp for stability
            last = now;

            // Clear
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw layers
            drawClockFace();
            drawTicks();
            drawNumbers();
            drawAsteroids(dt);

            // Time & hands
            const t = new Date();
            const hr = t.getHours();
            const min = t.getMinutes();
            const sec = t.getSeconds();
            const ms = t.getMilliseconds();
            const sSmooth = sec + ms / 1000;
            const mSmooth = min + sSmooth / 60;
            const hSmooth = (hr % 12) + mSmooth / 60;
            const aS = (sSmooth * Math.PI * 2) / 60 - Math.PI / 2;
            const aM = (mSmooth * Math.PI * 2) / 60 - Math.PI / 2;
            const aH = (hSmooth * Math.PI * 2) / 12 - Math.PI / 2;

            drawHand(aH, 0.50, 0.010, '#9b59b6');
            drawHand(aM, 0.70, 0.007, '#0ff');
            drawHand(aS, 0.80, 0.004, '#e74c3c');

            digitalTime.textContent = formatTime(t);
            if (ms < 100) { digitalTime.classList.add('pulse'); setTimeout(() => digitalTime.classList.remove('pulse'), 180); }

            drawExplosions(dt);

            requestAnimationFrame(loop);
        }

        // Init
        resizeCanvas();
        new ResizeObserver(resizeCanvas).observe(canvas);
        window.addEventListener('orientationchange', resizeCanvas);
        requestAnimationFrame(loop);

        // Repopulate asteroids occasionally if all are destroyed
        setInterval(() => {
            if (asteroids.every(a => a.destroyed)) {
                asteroids.length = 0; for (let i = 0; i < ASTERIOD_COUNT; i++) asteroids.push(makeAsteroid());
            }
        }, 1500);
    </script>
</body>

</html>